# 데이터 프레임 생성
#### 리스트로 데이터 프레임 만들기

- DataFrame([[list1],[list2]]) 
- 각 list는 한 행으로 구성됨
- 행의 원소 개수가 다르면 None 값으로 저장

# 1차원 리스트를 이용해서 df 생성
df = pd.DataFrame(['a','b','c'])
   0
0  a
1  b
2  c

# 2차원 리스트를 이용해서 df 생성 - 하위 리스트가 각 행으로 매핑
df = pd.DataFrame([['a','b','c'], ['a','a','g']])
	0	1	2
0	a	b	c
1	a	a	g

# 하위리스트의 원소의 개수가 서로 다른 경우 - None 값을 저장
df = pd.DataFrame([['a','b','c'], ['a','a','g'], ['a','a']])
	0	1	2
0	a	b	c
1	a	a	g
2	a	a	None

### 딕셔너리로 데이터 프레임 생성
- dict의 key -> colum name

df1= pd.DataFrame({'A':[90,80,70],
                   'B':[85,98,75],
                   'C':[88,99,77],                   
                   'D':[87,89,86]},
                 index=[0,1,2])
df1
	A	B	C	D
0	90	85	88	87
1	80	98	99	89
2	70	75	77	86


data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2000002],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율":[0.0283, 0.0163, 0.0982,0.0141]
}

#열방향 인덱스(컬럼명) columns=
columns = ['지역','2015','2010','2005','2000','2010-2015 증가율']

#행방향 인덱스 index =
index=['서울','부산','인천','대구']

# pd.DataFrame(데이터, index=, columns= )

df3 = pd.DataFrame(data, index = index, columns = columns)
df3
	지역	2015	2010	2005	2000	2010-2015 증가율
서울	수도권	9904312	9631482	9762546	9853972	0.0283
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982
대구	경상권	2466052	2000002	2456016	2473990	0.0141


### 시리즈로 데이터 프레임 생성
- pd.DataFrame(시리즈) : 시리즈를  열로 정의 - 1개의 시리즈가 전달
-  여러개의 시리즈를 이용해서 데이터 프레임 생성 : 리스트로 묶어서 전달
    - pd.DataFrame([시리즈1, 시리즈2, ...] ): 리스트 원소 시리즈 1개가 한 행으로 정리

a = pd.Series([100, 200, 300], ['a', 'b', 'd'])
b = pd.Series([101, 201, 301], ['a', 'b', 'k'])
c = pd.Series([110, 210, 310], ['a', 'b', 'c'])
print(pd.DataFrame(a))  # 시리즈를 열로 정의 -. 1개의 시리즈가 전달
pd.DataFrame([a])      # 리스트 원소 시리즈 1개가 한 행으로 정의
     0
a  100
b  200
d  300

a	b	d
0	100	200	300

pd.DataFrame([a,b,c])
a	b	d	k	c
0	100.0	200.0	300.0	NaN	NaN
1	101.0	201.0	NaN	301.0	NaN
2	110.0	210.0	NaN	NaN	310.0

#### csv 데이터로 부터 Dataframe 생성
 - 데이터 분석을 위해, dataframe을 생성하는 가장 일반적인 방법
 - 데이터 소스로부터 추출된 csv(comma separated values) 파일로부터 생성
 - pandas.read_csv 함수 사용

train_data = pd.read_csv('C:/DataScience/data/train.csv')
print(train_data.shape)
train_data.head() # df의 처음 5행을 출력
train_data.head(10) # df의 처음 10행을 출력
train_data.tail() # 마지막 5행을 출력
(891, 12)	# 891행 12열

PassengerId	Survived	Pclass	Name	Sex	Age	SibSp	Parch	Ticket	Fare	Cabin	Embarked
886	887	0	2	Montvila, Rev. Juozas	male	27.0	0	0	211536	13.00	NaN	S
887	888	1	1	Graham, Miss. Margaret Edith	female	19.0	0	0	112053	30.00	B42	S
888	889	0	3	Johnston, Miss. Catherine Helen "Carrie"	female	NaN	1	2	W./C. 6607	23.45	NaN	S
889	890	1	1	Behr, Mr. Karl Howell	male	26.0	0	0	111369	30.00	C148	C
890	891	0	3	Dooley, Mr. Patrick	male	32.0	0	0	370376	7.75	NaN	Q


#### read_csv 함수 파라미터
 - sep - 각 데이터 값을 구별하기 위한 구분자(separator) 설정 
 - header - header를 무시할 경우, None 설정
 - index_col - index로 사용할 column 설정
 - usecols - 실제로 dataframe에 로딩할 columns만 설정

train_data = pd.read_csv('c:/DataScience/data/train.csv', 
                         index_col = 'PassengerId',
                        usecols=['PassengerId', 'Survived', 'Pclass', 'Name'])
train_data

	Survived	Pclass	Name
PassengerId			
1	0	3	Braund, Mr. Owen Harris
2	1	1	Cumings, Mrs. John Bradley (Florence Briggs Th...
3	1	3	Heikkinen, Miss. Laina
4	1	1	Futrelle, Mrs. Jacques Heath (Lily May Peel)
5	0	3	Allen, Mr. William Henry
...	...	...	...
887	0	2	Montvila, Rev. Juozas
888	1	1	Graham, Miss. Margaret Edith
889	0	3	Johnston, Miss. Catherine Helen "Carrie"
890	1	1	Behr, Mr. Karl Howell
891	0	3	Dooley, Mr. Patrick

train_data.columns
Index(['Survived', 'Pclass', 'Name'], dtype='object')

train_data.index
int64Index([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,
            ...
            882, 883, 884, 885, 886, 887, 888, 889, 890, 891],
           dtype='int64', name='PassengerId', length=891)

#### 인덱스와 컬럼의 이해

1. 인덱스(index)
 - index 속성
 - 각 아이템을 특정할 수 있는 고유의 값을 저장
 - 복잡한 데이터의 경우, 멀티 인덱스로 표현 가능
 
 
2. 컬럼(column)
 - columns 속성
 - 각각의 특성(feature)을 나타냄
 - 복잡한 데이터의 경우, 멀티 컬럼으로 표현 가능


df3
	지역	2015	2010	2005	2000	2010-2015 증가율
서울	수도권	9904312	9631482	9762546	9853972	0.0283
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982
대구	경상권	2466052	2000002	2456016	2473990	0.0141

# df의 컬럼명(열 인덱스) 확인 - columns 속성
df3.colums
Index(['지역', '2015', '2010', '2005', '2000', '2010-2015 증가율'], dtype='object')

# df의 인덱스(행 인덱스) 확인 - index 속성
df3.index
Index(['서울', '부산', '인천', '대구'], dtype='object')

### 행/열 인덱스 이름 설정
- index.name
- columns.name

df3.index.name = '도시'
df3.columns.name = '특성'
df3

특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	0.0283
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982
대구	경상권	2466052	2000002	2456016	2473990	0.0141

# df 프레임의 data 값만 추출하려면 values 속성 사용
df3.values # np.array 형태
df3.values[0]
array(['수도권', 9904312, 9631482, 9762546, 9853972, 0.0283], dtype=object)

# 데이터프레임명.shape : (row, column)
 - 데이터 전체 양 확인
df3.shape
(4, 6)

# 데이터프레임명.info 
 - 개요 정보 출력
df3.info
<bound method DataFrame.info of 특성   지역     2015     2010     2005     2000  2010-2015 증가율
도시                                                        
서울  수도권  9904312  9631482  9762546  9853972         0.0283
부산  경상권  3448737  3393191  3512547  3655437         0.0163
인천  수도권  2890451  2632035  2517680  2466338         0.0982
대구  경상권  2466052  2000002  2456016  2473990         0.0141>

# pandas 실수 출력 형식 변경 코드
pd.options.display.float_format = '{:.2f}'.format # 일반 실수 표현

# DataFrame의 기본 통계량 출력 - df.describe()
df3.describe()
특성	2015	2010	2005	2000	2010-2015 증가율
count	4.00	4.00	4.00	4.00	4.00
mean	4677388.00	4414177.50	4562197.25	4612434.25	0.04
std	3507775.58	3524530.93	3500544.86	3538749.06	0.04
min	2466052.00	2000002.00	2456016.00	2466338.00	0.01
25%	2784351.25	2474026.75	2502264.00	2472077.00	0.02
50%	3169594.00	3012613.00	3015113.50	3064713.50	0.02
75%	5062630.75	4952763.75	5075046.75	5205070.75	0.05
max	9904312.00	9631482.00	9762546.00	9853972.00	0.10

### 데이터 프레임 전치
- 판다스 데이터 프레임은 전치를 포함해서 Numpy 2차원 배열에서 사용할 수 있는 속성이나 메서드를 대부분 지원함
- 전치 : 행과 열을 바꿈
        - 관련 속성 :  df.T

print(type(df.T))
df3.T # 원본데이터에 반영되지 않는다.

# df3 전치
df3.T['서울'] # dtype : object

특성
지역                   수도권
2015             9904312
2010             9631482
2005             9762546
2000             9853972
2010-2015 증가율     0.0283
Name: 서울, dtype: object

### 데이터프레임 내용 변겅 :
- 열추가, 열삭제, 내용갱신

df3

특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	0.0283
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982
대구	경상권	2466052	2000002	2456016	2473990	0.0141

# 열 내용 갱신
df3['2010-2015 증가율'] * 100
도시
서울    2.83
부산    1.63
인천    9.82
대구    1.41
Name: 2010-2015 증가율, dtype: float64

# 새로운 열 추가
df3['2005-2015 증가율'] = ((df3['2015'] - df3['2005']) / df3['2005'] * 100).round(2)

특성	지역	2015	2010	2005	2000	2010-2015 증가율	2005-2015 증가율
도시							
서울	수도권	9904312	9631482	9762546	9853972	0.0283	1.45
부산	경상권	3448737	3393191	3512547	3655437	0.0163	-1.82
인천	수도권	2890451	2632035	2517680	2466338	0.0982	14.81
대구	경상권	2466052	2000002	2456016	2473990	0.0141	0.41

# 열 삭제
del df3['2010-2015 증가율']

특성	지역	2015	2010	2005	2000	2005-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	1.45
부산	경상권	3448737	3393191	3512547	3655437	-1.82
인천	수도권	2890451	2632035	2517680	2466338	14.81
대구	경상권	2466052	2000002	2456016	2473990	0.41

## 데이터프레임 기본 인덱싱
1. 열인덱싱
2. 인덱서를 사용하지 않는 행기준 인덱싱
- []기호를 이용해서 인덱싱할때 주의점 : []기호는 열 위주 인덱싱이 원칙

# 특정 열 추출 (시리즈 형태로 반환)
df3['지역']
df3.지역
서울    수도권
부산    경상권
인천    수도권
대구    경상권
Name: 지역, dtype: object

# 특정 열 추출 (데이터프레임으로 반환)
- 열 추출할때 데이터프레임으로 반환받고자 하면 컬럼명을 리스트 형태로 사용
df3[['지역']]
	지역
서울	수도권
부산	경상권
인천	수도권
대구	경상권

# 여러개의 열 추출 - [] 리스트 사용 (데이터 프레임으로 반환)
df3[['2010','2015']]
	2010	2015
서울	9631482	9904312
부산	3393191	3448737
인천	2632035	2890451
대구	2000002	2466052

### 판다스 데이터 프레임에 열이름(컬럼명)이 문자열일 경우에는
- 수치 인덱스를 사용할 수 없음
- 위치 인덱싱 기능을 사용할 수 없다. : keyerror 발생

# reshape(행,열)
np.arange(12)
np.arange(12).reshape(3,4)
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

df5 = pd.DataFrame(np.arange(12).reshape(3,4))
df5
	0	1	2	3
0	0	1	2	3
1	4	5	6	7
2	8	9	10	11

df5[[1,2]]   # 위치 인덱싱이 아닌 컬럼명이 숫자로 되어 있는 df의 인덱싱
	1	2
0	1	2
1	5	6
2	9	10

## 행 단위 인덱싱
- 행단위 인덱싱을 하고자 하면 인덱서라는 특수 기능을 사용하지 않는 경우 슬라이싱을 해야 함(인덱서는 바로 뒤에 배움)
- 인덱스 값이 문자(라벨)면 문자슬라이싱도 가능하다

# 1 행 추출 [:-1] - 슬라이싱 사용
df3[:1]

지역	2015	2010	2005	2000	2010-2015 증가율
서울	수도권	9904312	9631482	9762546	9853972	0.0283

df3[1:3] #[시작위치 : 끝위치 + 1]
지역	2015	2010	2005	2000	2010-2015 증가율
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982


# 개별 요소 접근
- 데이터프레임명[행][명]
df3['2015']['서울']
9904312




















